---
layout: post
title:  "Radial Basis Function (WIP)"
date:	2018-11-05 21:34:00 -0300
subtitle: "Entendendo uma Radial Basis Function Network"
comments: true
categories: Machine-learning data-science
---

Resoluação de sistemas pelo metodo da matriz inversa

$$
fx=\begin{cases}
    2a1+1a2=4\\
    1a1+1a2=3
\end{cases}
$$

Reescrevendo em forma de matriz:

$$
\begin{bmatrix}
    2 & 1\\
    1 & 1
\end{bmatrix} \ .
\begin{bmatrix}
    a1\\
    a2
\end{bmatrix} =
\begin{bmatrix}
    4\\
    3
\end{bmatrix}
$$
 
 Podemos utilizar a equação:

$$
\begin{bmatrix}
    R
\end{bmatrix} .
\begin{bmatrix}
    a
\end{bmatrix} =
\begin{bmatrix}
    A
\end{bmatrix}
$$

Isolando a matriz *a*

$$
\begin{bmatrix}
    a
\end{bmatrix} =
\begin{bmatrix}
    R
\end{bmatrix}^{-1}\ .
\begin{bmatrix}
    A
\end{bmatrix}
$$

Obtemos

$$
\begin{bmatrix}
    a1\\
    a2
\end{bmatrix} =
\begin{bmatrix}
    1 & -1\\
    -1 & 2
\end{bmatrix}.
\begin{bmatrix}
    4\\
    3
\end{bmatrix}
$$

Que resulta em

$$
\begin{bmatrix}
    a1\\
    a2
\end{bmatrix} =
\begin{bmatrix}
    1\\
    2
\end{bmatrix}
$$

Porém so conseguimos encontrar a matriz inversa à partir de uma matriz quadrada.
Uma forma de resolver o sistema  não quadrado e utilizando a [matriz pseudo-inversa](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse)
descoberta por [Moore](https://en.wikipedia.org/wiki/E._H._Moore)

Que deduz:


$$
\begin{bmatrix}
    R
\end{bmatrix} =
\begin{bmatrix}
    a
\end{bmatrix}\ .
\begin{bmatrix}
    A
\end{bmatrix}
$$

$$
\begin{cases}
1a1\ +\ 2a2\ +\ 1a3\ =4\\
2a1\ +\ 3a2\ +\ 1a3\ =6\\
4a1\ +\ 1a2\ +\ 2a2\ =7\\
1a1\ +\ 5a2\ +\ 2a3\ =8
\end{cases}
$$


$$
\begin{bmatrix}
    a
\end{bmatrix} =
\frac{1}{[ R]} \ 
\begin{bmatrix}
    A
\end{bmatrix}
$$  

onde 

$$\frac{1}{[ R]} =\left([ R]^{t} .[ R]\right)^{-1} .[ R]^{t}$$


$$
\begin{bmatrix}
    1 & 2 & 1\\
    2 & 3 & 1\\
    4 & 1 & 2\\
    1 & 5 & 2
\end{bmatrix} .\begin{bmatrix}
    a1\\
    a2\\
    a3
\end{bmatrix} =\begin{bmatrix}
    4\\
    6\\
    8\\
    7
\end{bmatrix}
$$

Encontrando 1/[R]:

$$
\begin{pmatrix}
\begin{bmatrix}
    1 & 2 & 4 & 1\\
    2 & 3 & 1 & 5\\
    1 & 1 & 2 & 2
\end{bmatrix} .\begin{bmatrix}
    1 & 2 & 1\\
    2 & 3 & 1\\
    4 & 1 & 2\\
    1 & 5 & 1
\end{bmatrix}
\end{pmatrix}^{-1} .\begin{bmatrix}
    1 & 2 & 4 & 1\\
    2 & 3 & 1 & 5\\
    1 & 1 & 2 & 2
\end{bmatrix}
$$


$$
\begin{pmatrix}
\begin{bmatrix}
    22 & 17 & 13\\
    17 & 39 & 17\\
    13 & 17 & 10
\end{bmatrix}
\end{pmatrix}^{-1} .\begin{bmatrix}
    1 & 2 & 4 & 1\\
    2 & 3 & 1 & 5\\
    1 & 1 & 2 & 2
\end{bmatrix}
$$


$$
\begin{bmatrix}
    0.3960 & 0.2000 & -0.8549\\
    0.2000 & 0.2000 & -0.6000\\
    -0.8549 & -0.6000 & 2.2313
\end{bmatrix} .\begin{bmatrix}
    1 & 2 & 4 & 1\\
    2 & 3 & 1 & 5\\
    1 & 1 & 2 & 2
\end{bmatrix}
$$


$$
\begin{bmatrix}
    -0.058 & 0.537 & 0.074 & -0.313\\
    0.000 & 0.400 & -0.200 & 0.000\\
    0.176 & -1.278 & 0.443 & 0.607
\end{bmatrix}
$$

Voltando para a equação


$$
\begin{bmatrix}
    a
\end{bmatrix} =
\frac{1}{[ R]} \ 
\begin{bmatrix}
    A
\end{bmatrix}
$$  

$$
[a] =\begin{bmatrix}
    -0.058 & 0.537 & 0.074 & -0.313\\
    0.000 & 0.400 & -0.200 & 0.000\\
    0.176 & -1.278 & 0.443 & 0.607
\end{bmatrix} .\begin{bmatrix}
    4\\
    6\\
    7\\
    8
\end{bmatrix}
$$

$$
[ a] =\begin{bmatrix}
    1\\
    1\\
    1\\
    1
\end{bmatrix}
$$

$$
f( x) =\sum ^{P}_{p=1} a_{p} .R_{p} +b
$$


$$
\begin{array}{ c c }
x & f( x)\\
2 & 3\\
3 & 6\\
4 & 5
\end{array}
$$

Utilizando dois polos:


C1=2
C2=4



$$\sigma ^{2} =1$$


$$
R_{p} = e^{-\frac{1}{2\sigma ^{2}} .\parallel ( X_{i}) -( X_{p}) \parallel ^{2}}
$$

```
Rp= e ^(-(1/(2sigma^2)) . ||(Xl)-(Cp)||^3)

Rp= e^(-0.5 . ||(Xl)-(Cp)||^2)


f(Xl) = sum_{p=1}^{2}  ap .Rp + b

{e^(-0.5||2-2||^2) .a1 + e^(-0.5||2-4||^2) .a2 + b = 3
{e^(-0.5||3-2||^2) .a1 + e^(-0.5||3-4||^2) .a3 + b = 6
{e^(-0.5||4-2||^2) .a1 + e^(-0.5||4-4||^2) .a3 + b = 5

{e^-0.0 .a1 + e^-2.0 .a2 + b = 3
{e^-0.5 .a1 + e^-0.5 .a2 + b = 6
{e^-2.0 .a1 + e^-0.0 .a2 + b = 5

{1.000.a1 + 0.135.a2 + b.1.00 = 3
{0.606.a1 + 0.606.a2 + b.1.00 = 6
{0.135.a1 + 1.000.a2 + b.1.00 = 5

Resolvendo o sistema

|1.000 0.135 1.000|   |a1|   |3|
|0.605 0.606 1.000| . |a2| = |6|
|0.135 1.000 1.000|   |b |   |5|

([R]^t . [R])^-1 . [R]^t

[a] = (1/[R]) . [A]

      |-5.8546 12.8657 -7.0111|   |3|
[a] = |-7.0111 12.8657 -5.8546| . |4|
      | 7.8034 -14.069  7.8034|   |5|

      [+24.5749]
[a] = [+26.8879]
      [-25.2138]


f(Xl) = sum_{p=1}^{2}  ap .Rp + b


f(Xl) = a1 .R1 + a2 .R2 + b

f(Xl) = +24.5749 .R1 + +26.8879 .R2 + -25.2138

f(Xl) = +24.5749 .e^(-0.5||X-2||^2) + +26.8879 .e^(-0.5||X-4||^2) + -25.2138

Resultado:

para X=2:

f(2) = 24.5749 .e^0 + +26.8879 .e^-2 + -25.2138 = 3

para X=3:

f(3) = 24.5749 .e^0.5 + +26.8879 .e^-0.5 + -25.2138 = 6

para X=4:

f(4) = 24.5749 .e-2.0 + +26.8879 .e^0 + -25.2138 = 5

```

## Exemplo prático

```python
import numpy as np
from math import exp, pow
from numpy.linalg import inv
from functools import reduce
import matplotlib.pyplot as plt

def rbf(inp, out, center):
    def euclidean_norm(x1, x2):
        return sqrt(((x1 - x2)**2).sum(axis=0))

    def gaussian (x, c):
        return exp(-0.5 * pow(euclidean_norm(x, c), 2))

    R = np.ones((len(inp), (len(center) + 1)))

    for i, iv in enumerate(inp):
        for j, jv in enumerate(center):
            R[i, j] = (gaussian(inp[i], center[j]))

    Rt = R.transpose()
    RtR = Rt.dot(R)
    iRtR = inv(RtR)
    oneR = iRtR.dot(Rt)
    a = oneR.dot(out)

    def rbf_interpolation(x):
        sum = np.ones(len(center) + 1)

        for i, iv in enumerate(center):
            sum[i] = gaussian(x, iv)

        y = a * sum
        return reduce((lambda x, y: x + y), y)

    return rbf_interpolation
```

```python
inp = np.array([2, 3, 4])
out = np.array([3, 6, 5])
center = np.array([2, 4])

rbf_instance = rbf(inp, out, center)

input_test = input_test = np.linspace(0,10,100)
output_test = list(map(rbf_instance, input_test))

plt.plot(input_test, output_test)
plt.plot(inp, out, 'ro')
plt.ylabel('expected vs predicted')
plt.show()
```

![{{ site.baseurl }}/assets/img/rbf1.svg]({{ site.baseurl }}/assets/img/rbf1.svg)

```python
inp = np.array([2, 3, 4, 5])
out = np.array([3, 1, 5, -2])
center = np.array([2, 3, 4])

rbf_instance = rbf(inp, out, center)

input_test = np.linspace(-5,10,100)
output_test = list(map(rbf_instance, input_test))

plt.plot(input_test, output_test)
plt.plot(inp, out, 'ro')
plt.ylabel('expected vs predicted')
plt.show()
```

![{{ site.baseurl }}/assets/img/rbf1.svg]({{ site.baseurl }}/assets/img/rbf2.svg)

```python
inp = np.array([2, 4, 7, 9])
out = np.array([7, 8, 9, 5])
center = np.array([2, 3, 4])

rbf_instance = rbf(inp, out, center)

input_test = input_test = np.linspace(-5,15,100)
output_test = list(map(rbf_instance, input_test))

plt.plot(input_test, output_test)
plt.plot(inp, out, 'ro')
plt.ylabel('expected vs predicted')
plt.show()
```

![{{ site.baseurl }}/assets/img/rbf1.svg]({{ site.baseurl }}/assets/img/rbf3.svg)


```python
inp = np.array([np.array([1,1]), np.array([0,1]), np.array([0,0]), np.array([1,0])])
out = np.array([              0,               1,               0,             1])
center = np.array([ np.array([1,1]), np.array([0,0])])

rbf_instance = rbf(inp, out, center)


inp_test = np.array([np.array([1,1]), 
                     np.array([0,1]), 
                     np.array([0,0]), 
                     np.array([1,0])])
output = map(rbf_instance, inp_test)

def colorize(output):
    c = [None]* len(output)
    for i, iv in enumerate(output):
        if (output[i] > 0):
            c[i] = 'blue'
        else:
            c[i] = 'red'
    return c

inp_x = [1, 0, 0, 1]
inp_y = [1, 1, 0, 0]

c = colorize(output)

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

ax.scatter(inp_x, inp_y, output, color=c, depthshade=False)
plt.show()
```

![{{ site.baseurl }}/assets/img/rbf1.svg]({{ site.baseurl }}/assets/img/rbf_xor.svg)
